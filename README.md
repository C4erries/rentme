# Rentme — платформа аренды жилья с ML-ценами

Rentme — это маркетплейс (биржа) для аренды жилья, похожий по идее на Airbnb.  
Платформа не привязана к одному отелю, ЖК или застройщику — это единая точка встречи арендодателей и арендаторов для краткосрочной и долгосрочной аренды.

Основные идеи:
- единая витрина объявлений по аренде квартир, комнат, домов;
- работа как с краткосрочной, так и с долгосрочной арендой;
- отдельный ML‑сервис, который помогает с ценообразованием;
- развитие в сторону микросервисной архитектуры и продвинутой наблюдаемости.

> Краткое резюме по‑английски:  
> *Rentme is a marketplace for short‑ and long‑term rentals (Airbnb‑like), with a planned ML pricing service, chat between hosts and guests, notifications, maps integration, and an architecture that is ready to be split into microservices.*

---

## Продуктовое видение

### Что есть сейчас (high‑level)

- Каталог объявлений и доменная модель объектов аренды.
- Календарь доступности и базовый функционал бронирования.
- Backend сервис на Go с API под SPA‑фронтенд.
- Frontend на React + TypeScript + Vite + Tailwind CSS.
- Локальный запуск через `docker-compose` с MongoDB и Kafka.

### Что планируется

1. **ML‑сервис ценообразования (отдельный сервис)**
   - Оценка того, насколько текущая цена объявления «хорошая» относительно рынка.
   - Рекомендации цены при создании или редактировании объявления.
   - Возможность использовать историю спроса/запросов и сезонность.

2. **Функционал выставления объявлений**
   - Создание и редактирование объявлений арендодателем.
   - Управление календарём доступности и ценами по датам.

3. **Мессенджер арендодатель ↔ арендатор (дальняя перспектива)**
   - Общение до заключения контракта: вопросы по объекту, условия, детали заезда.
   - Общение после заселения: показания счётчиков, бытовые вопросы, задачи в период аренды.
   - Хранение истории чатов в **ScyllaDB** для эффективной и масштабируемой работы.

4. **Система оповещений**
   - Уведомления о новых сообщениях в чате.
   - Напоминания о платежах, проверках, показаниях счётчиков.
   - Каналы: e‑mail, push, мессенджеры (по мере развития).

5. **Интеграция с картами**
   - Интеграция с картами (скорее всего, Яндекс.Карты).
   - Отображение объектов на карте, поиск по локации и району.

6. **Наблюдаемость и микросервисы**
   - Внедрение **ELK‑стека** (Elasticsearch, Logstash/Beats, Kibana) для логов и аналитики.
   - Постепенное разбиение backend на микросервисы:
     - сервис объявлений,
     - сервис бронирований,
     - ML‑сервис цен,
     - сервис мессенджера,
     - сервис уведомлений и т.п.

---

## Архитектура репозитория

Корень проекта:

- `backend/` — Go‑backend (модуль `rentme`).
- `frontend/` — SPA‑фронтенд на React + Vite.
- `docker-compose.yml` — локальная среда разработки (backend, frontend, MongoDB, Kafka).

### Backend (`backend/`)

- Язык: **Go 1.24**.
- HTTP‑фреймворк: **Gin**.
- Хранилище и очереди (по окружению):
  - **MongoDB** — основная БД (поддержка в конфигурации, фактическое использование может развиваться).
  - **Kafka** — для событий и outbox‑паттерна.
- Логи: `internal/infra/obs/logger.go` — обёртка над `log/slog` с dev/JSON режимами.
- Организация кода (приближена к DDD и микросервисам):
  - `internal/domain` — доменные модели и бизнес‑логика (объявления, доступность, бронирование, ценообразование и др.).
  - `internal/app` — команды, запросы, обработчики HTTP, middleware, outbox.
  - `internal/infra` — инфраструктура (HTTP‑сервер, логирование, storage, конфигурация).
  - `backend/data/listings.json` — фикстуры объявлений для локального запуска.

Главный вход: `backend/cmd/rentme/main.go`:
- настраивает логгер и конфигурацию;
- поднимает HTTP‑сервер Gin;
- грузит фикстуры объявлений из `data/listings.json` (или пути из `LISTINGS_FIXTURES`);
- регистрирует команды и запросы:
  - бронирования,
  - календарь доступности,
  - каталог/обзор объявлений.

Архитектура backend задумана как **модульный монолит**, который в будущем можно разбить на отдельные сервисы, не ломая доменную модель.

### Frontend (`frontend/`)

- Стек:
  - **React 19**,
  - **TypeScript**,
  - **Vite**,
  - **Tailwind CSS**.
- Dockerfile собирает статический бандл и отдаёт его через **nginx**.
- `nginx.conf`:
  - раздаёт SPA (`index.html`);
  - проксирует `location /api/` на backend (`http://rentme:8080`).
- Переменные окружения сборки:
  - `VITE_API_BASE_URL` (в Docker по умолчанию `/api/v1`).

---

## Запуск локально

### 1. Через Docker Compose (рекомендуется)

Требования:
- Docker и Docker Compose.

Команда из корня репозитория:

```bash
docker-compose up --build
```

После успешного старта:
- Frontend: http://localhost:3000
- Backend API: http://localhost:8080 (и через фронтенд — `/api/v1`)
- MongoDB: `mongodb://localhost:27017`
- Kafka: `localhost:9092`

Фикстуры объявлений будут загружены автоматически из `backend/data/listings.json` (или по пути из `LISTINGS_FIXTURES`).

### 2. Запуск вручную (без Docker)

Минимальный сценарий:

1. Поднять MongoDB и Kafka локально (или через отдельный `docker-compose`).
2. Backend:

```bash
cd backend
go run ./cmd/rentme
```

При необходимости можно задать:

```bash
APP_ENV=dev
HTTP_ADDR=:8080
MONGO_URI=mongodb://localhost:27017
MONGO_DB=rentals
KAFKA_BROKERS=localhost:9092
KAFKA_TOPIC_PREFIX=rentme
```

3. Frontend:

```bash
cd frontend
npm install
npm run dev
```

и открыть URL, который покажет Vite (по умолчанию `http://localhost:5173`), с `VITE_API_BASE_URL`, указывающим на backend (например, `http://localhost:8080/api/v1`).

---

## Дальнейшее развитие и дорожная карта

Планируемые шаги (high‑level):

- **ML‑сервис ценообразования**
  - Отдельный сервис/микросервис, взаимодействующий с основным backend (HTTP/gRPC или события через Kafka).
  - Отдельная модель/хранилище для исторических данных цен и спроса.

- **Мессенджер и ScyllaDB**
  - Выделенный сервис чатов.
  - ScyllaDB как основное хранилище сообщений (по user‑pair + listing + time).
  - Интеграция с системой уведомлений.

- **Сервис уведомлений**
  - Единая точка отправки уведомлений, подписка на события от других сервисов.

- **Интеграция с картами**
  - Логика работы с провайдером карт (вероятнее всего, Яндекс.Карты) вынесена в отдельный модуль/сервис.

- **ELK‑стек и observability**
  - Централизованные логи, дешборды, алерты.
  - Связка с существующим `slog`‑логированием в backend.

- **Разбиение на микросервисы**
  - Явные границы контекстов: listings, booking, pricing, messaging, notifications.
  - Контракты между сервисами: API, события, схемы сообщений.

---

## Для разработчиков и AI‑агентов

Этот раздел описывает важные принципы, которых стоит придерживаться при доработке проекта (как людям, так и AI‑агентам).

1. **Очень важно: это маркетплейс, а не сайт одного объекта**
   - При проектировании доменов и API всегда думайте о многих арендодателях и множестве объектов.
   - Избегайте решений, которые привязывают систему к одному ЖК, отелю или застройщику.

2. **Готовность к микросервисам**
   - Доменная логика должна быть изолирована в `internal/domain`.
   - Обработчики команд/запросов — в `internal/app`, без жёсткой привязки к конкретному transport‑слою.
   - Инфраструктура (`internal/infra`) не должна «знать» детали домена больше необходимого.
   - Старайтесь проектировать так, чтобы любой контекст (объявления, бронирования, pricing, мессенджер) можно было вынести в отдельный сервис без переписывания бизнес‑логики.

3. **ML‑pricing и мессенджер как отдельные контексты**
   - ML‑ценообразование — независимый сервис с чётким API: вход (данные об объекте, рынке), выход (рекомендованные цены, оценка качества текущей цены).
   - Мессенджер должен изначально проектироваться так, чтобы:
     - хранить историю в ScyllaDB,
     - поддерживать многопоточность диалогов (пользователь ↔ пользователь, пользователь ↔ support и т.д.),
     - масштабироваться независимо от основного backend.

4. **API‑договоры и версияция**
   - Текущая версия HTTP API — `/api/v1` (см. `frontend/nginx.conf` и конфигурацию Vite).
   - Изменения в API по возможности делайте backward‑compatible; breaking changes — только с продуманной миграцией.

5. **Наблюдаемость и логи**
   - Используйте `obs.NewLogger` для создания логгеров.
   - Стремитесь к структурированным логам с ключами, которые будет удобно анализировать в ELK.

6. **Frontend‑правила**
   - Поддерживайте единый дизайн‑язык на базе Tailwind CSS.
   - Храните состояние и работу с API так, чтобы их можно было переиспользовать между страницами (в перспективе — между несколькими фронтенд‑приложениями).

Если вы добавляете новые файлы или сервисы, ориентируйтесь на текущую структуру и это README.  
Для более детальных инструкций для AI‑агентов можно завести дополнительные `AGENTS.md` в соответствующих директориях.

