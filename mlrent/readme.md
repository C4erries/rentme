## ML‑сервис оценки стоимости квартиры (Rentme)

Этот каталог описывает ML‑подсистему Rentme, которая отвечает за **оценочную стоимость аренды квартиры** и интеграцию с доменом `pricing` на бэкенде.

Подробнее о постановке задачи и сопоставлении полей см. `problem.md`. В этом файле — краткое описание целевого сервиса и его места в архитектуре.

---

### 1. Назначение сервиса

- Предсказывать **рекомендованную ночную цену** (`recommended_nightly_rate_cents`) для объявления (`Listing`).
- Использоваться бэкендом через доменный интерфейс `pricing.Calculator`:
  - для эндпоинта хоста `/api/v1/host/listings/:id/price-suggestion`;
  - потенциально — для предзаполнения цены при создании объявления.
- Работать как **отдельный процесс/контейнер** на Python, который можно в будущем вынести в отдельный микросервис.

---

### 2. Источники данных и схема признаков

Источники:
- **доменные данные** Rentme:
  - `Listing` из MongoDB (через Go‑репозиторий);
  - исторические `PriceBreakdown` / созданные бронирования (для таргета в будущей «боевой» модели);
- **учебный датасет** `clean_train.csv` / `clean_test.csv`:
  - используется как стартовая точка и пример структуры;
  - в будущем будет заменён генерацией датасета из доменной БД и/или синтетикой.

Целевая схема признаков для первой версии (все фичи должны быть доступны из `Listing` и его адреса):
- Локация:
  - `city`, `country`, `lat`, `lon`;
  - обобщённый признак близости к транспорту (`transport_minutes` или категориальный `near_transport_flag`);
- Характеристики квартиры:
  - `bedrooms`, `bathrooms`;
  - `area_total`, `area_living`, `area_kitchen`;
  - `floor`, `floors_total`;
- Правила и ограничения:
  - `guests_limit`, `min_nights`, `max_nights`;
- Тип и качество:
  - `property_type`;
  - `rating`;
  - агрегированные признаки по `amenities`, `tags`, `highlights` (например, количество удобств, флаг «есть кухня», флаг «подходит для работы»).

Производные признаки (`living_total_ratio`, `storey_ratio`, и т.п.) считаются на стороне ML из базовых полей.

---

### 3. Целевая переменная (таргет)

В домене Rentme уже есть:
- `Listing.NightlyRateCents` — текущая установленная хостом цена;
- исторические цены и итоговые суммы внутри `PriceBreakdown`.

В учебной постановке:
- можно стартовать с таргета, похожего на колонку `price` из `clean_train.csv`, приведённой к **цене за ночь** (например, деление на 30);
- для интеграции с бэкендом таргет должен быть в тех же единицах, что `NightlyRateCents` (целое число в минимальных денежных единицах — центы/копейки).

---

### 4. Интерфейс ML‑сервиса (черновой контракт)

Первый вариант интерфейса, который удобно покрывает текущие потребности бэкенда:

- `POST /predict`
  - Вход:
    ```json
    {
      "listing_id": "string",
      "snapshot": {
        "city": "Moscow",
        "country": "RU",
        "lat": 55.75,
        "lon": 37.61,
        "bedrooms": 2,
        "bathrooms": 1,
        "area_total": 60.0,
        "area_living": 32.0,
        "area_kitchen": 12.0,
        "floor": 9,
        "floors_total": 17,
        "guests_limit": 3,
        "min_nights": 2,
        "max_nights": 30,
        "property_type": "apartment",
        "rating": 4.8,
        "amenities": ["wifi", "kitchen", "workspace"],
        "tags": ["near-metro"],
        "highlights": ["city-view"]
      }
    }
    ```
    В реальной интеграции Go‑адаптер может сам собирать `snapshot` из `Listing` по `listing_id`.
  - Выход:
    ```json
    {
      "listing_id": "string",
      "recommended_nightly_rate_cents": 8500,
      "confidence": 0.78
    }
    ```

Контракт можно будет уточнить, но важно:
- не привязываться к конкретной реализации модели;
- делать поля snapshot‑а максимально близкими к доменной модели `Listing`.

---

### 5. Встраивание в Go‑код Rentme

Интеграция делается через существующие точки расширения:

- Доменный интерфейс:
  - `internal/domain/pricing.Calculator` — контракт, который уже использует `HostListingPriceSuggestionHandler`.
- Порт приложения:
  - `internal/app/policies.PricingPort` — адаптер, через который хендлеры обращаются к ценообразованию.
- Инфраструктурный адаптер:
  - новый `MLPricingEngine` в `internal/infra/...`:
    - по `QuoteInput{ ListingID, Range, Guests }` достаёт `Listing` из `UoW`;
    - формирует `snapshot` и вызывает HTTP‑эндпоинт ML‑сервиса;
    - укладывает ответ в `PriceBreakdown`.

Текущий `memory.PricingEngine` можно оставить как fallback / заглушку для dev‑окружения.

---

### 6. Обучающие данные и генерация синтетики

Так как проект учебный и данные будут генерироваться через нейросеть:

- генератор данных должен работать **от схемы Listing**:
  - сначала формируется набор реалистичных `Listing` (для наполнения БД и `backend/data/listings.json`);
  - затем на их основе формируется ML‑датасет со схожим набором признаков;
- это гарантирует, что:
  - нет фичей, которых нет в домене;
  - каждая фича, которую использует модель, может быть восстановлена по реальному объявлению.

Подробнее шаги реализации описаны в `plan.md`.

