## Проблема: согласовать ML‑сервис цены и доменную модель Rentme

Нужно, чтобы ML‑сервис по атрибутам квартиры выдавал **оценочную стоимость аренды** (ночная ставка), при этом:
- схема признаков в CSV‑датасете не противоречила доменной модели объявления (`Listing`);
- в домене не появлялись чисто аналитические/технические фичи;
- данные для обучения и предзаполнения базы можно было генерировать синтетически.

ML‑часть живёт в `mlrent/`, основной домен — в `backend/internal/domain`. Ниже зафиксированы решения по полям и их связи.

---

### 1. Текущая схема CSV‑датасетов

Оба датасета (`mlrent/clean_train.csv`, `mlrent/clean_test.csv`) имеют одинаковую структуру:

```text
id,city,price,minutes,way,rooms,total_area,storey,storeys,renovation,building_age_years
```

Семантика полей:
- `id` — технический идентификатор строки;
- `city` — город (в учебных данных сейчас всегда `Moscow`; в целом работаем по РФ);
- `price` — цена аренды (таргет модели, дальше будем приводить к ночной ставке);
- `minutes` — **время до центра города** в минутах;
- `way` — **тип пути до центра**:
  - `walk` — пешком;
  - `car` — на машине/транспорте;
- `rooms` — количество комнат (будем интерпретировать как `Bedrooms` в домене);
- `total_area` — общая площадь квартиры, м²;
- `storey` — этаж квартиры;
- `storeys` — всего этажей в доме;
- `renovation` — уровень ремонта от 0 до 10 (0 — без ремонта, 10 — современный качественный ремонт);
- `building_age_years` — возраст дома в годах.

Значения `minutes` пересчитаны из исходных «минут до метро» так, чтобы они выглядели реалистично как время до центра (порядка 10–35 минут; поездки на машине/транспорте обычно дают большее значение, чем пешком).

Удалены/не используются:
- `metro` — конкретная станция метро сейчас не входит в целевую схему;
- поведенческие и чисто технические поля исходного набора (`views`, `fee_percent` и т.п.);
- производные ratios (отношения площадей, этажей) — будут считаться на стороне ML по базовым полям.

---

### 2. Связь с доменной моделью `Listing`

Ключевой агрегат на бэкенде — `Listing` (`backend/internal/domain/listings/listing.go`). В контексте ценообразования и ML‑сервиса важны:

- Локация:
  - `Address.City`, `Address.Country`, `Address.Lat`, `Address.Lon`;
- Характеристики квартиры:
  - `Bedrooms`, `Bathrooms`;
  - `AreaSquareMeters` — общая площадь;
  - (планируемые поля) `Floor`, `FloorsTotal` — этаж и этажность дома;
- Цена и качество:
  - `NightlyRateCents` — ночная ставка;
  - `Rating`;
- Ограничения и правила:
  - `GuestsLimit`, `MinNights`, `MaxNights`;
  - `HouseRules`, `CancellationPolicyID`.

Отображение CSV → домен:
- `city` → `Address.City`;
- `rooms` → `Bedrooms`;
- `total_area` → `AreaSquareMeters`;
- `storey` → планируемое поле `Floor` в `Listing`;
- `storeys` → планируемое поле `FloorsTotal`;
- `price` → целевая цена, которую нужно нормализовать к масштабу `NightlyRateCents` (ночная цена в минимальных денежных единицах);
- `minutes` + `way` → признаки транспортной доступности до центра (в домене могут появиться как расширение адреса либо остаться чисто ML‑фичами);
- `renovation` → кандидат на поле `RenovationScore` (0–10) в `Listing`;
- `building_age_years` → возраст дома; для домена логичнее хранить `YearBuilt` или статический `BuildingAgeYears`, а в ML использовать производное число лет.

Таким образом, все признаки в CSV либо уже есть в доменной модели, либо имеют очевидных кандидатов на новые поля.

---

### 3. Что добавлять в домен, а что держать только в ML

**Рекомендуемые расширения `Listing` (доменный уровень):**
- `Floor int` — этаж;
- `FloorsTotal int` — этажность;
- `RenovationScore int` (0–10) — уровень ремонта;
- `BuildingAgeYears int` **или** `YearBuilt int` — информация о возрасте дома.

Эти поля полезны не только для ML, но и для бизнес‑функционала:
- фильтры «новый дом», «дом с хорошим ремонтом»;
- подсказки цен по сегментам качества и возраста.

**Фичи, которые можно оставить только в ML:**
- `minutes` и `way` — на первых итерациях могут вычисляться как внешние признаки (например, через гео‑расстояние и простую модель транспорта) и не храниться в `Listing`;
- производные признаки (любые ratios, комбинированные индексы «удалённости», «качества») считаются в ML‑коде на основе базовых полей домена.

---

### 4. Место ML‑сервиса в контексте pricing

В домене уже есть контекст `pricing` (`backend/internal/domain/pricing/pricing.go`):
- `PriceBreakdown` с полями `Nights`, `Nightly`, `Fees`, `Taxes`, `Discounts`, `Total`;
- интерфейс `Calculator` с методом `Quote(ctx, QuoteInput)`;
- на уровне приложения — порт `PricingPort` и хендлер `HostListingPriceSuggestionHandler`, который отдаёт хосту рекомендованную цену и уровень «ниже/выше рынка».

ML‑сервис должен стать реализацией `Calculator` через инфраструктурный адаптер:
- по `QuoteInput{ ListingID, Range, Guests }` адаптер читает `Listing` из БД;
- формирует в запросе к ML только согласованные фичи (в том числе `renovation`, `building_age_years`, `minutes`, `way`, если они есть);
- получает рекомендованную ночную цену и упаковывает её в `PriceBreakdown.Nightly`/`Total`.

Такое разделение позволяет:
- сохранить чистую доменную модель и готовность к выделению отдельного сервиса ценообразования;
- развивать ML‑часть независимо (отдельный сервис/контейнер);
- гарантировать, что модель использует только те признаки, которые можно получить из домена или однозначно из него вывести.

