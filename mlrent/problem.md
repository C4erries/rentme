## Постановка задачи: ML‑сервис ценообразования и связь с доменом Rentme

Задача: построить ML‑сервис, который по признакам квартиры даёт **оценочную стоимость аренды** и согласован с доменной моделью `Listing`, при этом:
- поддерживаются два типа аренды (`short_term` и `long_term`);
- для каждого типа аренды используется отдельная модель и отдельный датасет;
- сервис остаётся простым и понятным для учебного проекта.

ML‑часть живёт в `mlrent/`, бизнес‑логика и доменная модель — в `backend/internal/domain`.

---

### 1. Существующая схема CSV‑датасетов

В `mlrent/clean_train.csv` и `mlrent/clean_test.csv` строки имеют вид:

```text
id,city,price,minutes,way,rooms,total_area,storey,storeys,renovation,building_age_years
```

Где:
- `id` — технический идентификатор строки;
- `city` — город (например, `Moscow`);
- `price` — целевая стоимость (в обучении; в интеграции обычно близка к `NightlyRateCents`);
- `minutes` — оценка времени до центра, в минутах;
- `way` — способ добирания (`walk` / `car`);
- `rooms` — количество комнат;
- `total_area` — общая площадь, м²;
- `storey` — этаж;
- `storeys` — этажность;
- `renovation` — качество ремонта 0–10;
- `building_age_years` — возраст дома в годах.

Часть признаков (`minutes`, `way`) являются «инженерными» и могут быть получены из геоданных, но на первом этапе допустимо заполнять их разумными константами/генерацией.

---

### 2. Маппинг CSV → Listing

`Listing` описан в `domain_model.md` и в `backend/internal/domain/listings/listing.go`.

Соответствия:
- `city` ↔ `Listing.Address.City`
- `rooms` ↔ `Listing.Bedrooms`
- `total_area` ↔ `Listing.AreaSquareMeters`
- `storey` ↔ `Listing.Floor`
- `storeys` ↔ `Listing.FloorsTotal`
- `renovation` ↔ `Listing.RenovationScore`
- `building_age_years` ↔ `Listing.BuildingAgeYears`
- `price` ↔ таргетная цена (как правило, связана с `NightlyRateCents`)
- `minutes`, `way` ↔ производные признаки (гео + транспорт).

Дополнительные поля `Listing` (например, `GuestsLimit`, `MinNights`, `MaxNights`, `Rating`, `Region`) в текущую версию модели **не входят**. Это осознанное упрощение: модель опирается на компактный набор понятных признаков, а остальные могут использоваться в анализе или последующих версиях моделей.

---

### 3. Разделение short_term и long_term моделей

Бизнес‑требования:
- система поддерживает два типа аренды:
  - `short_term` — посуточная;
  - `long_term` — долгосрочная;
- для каждого типа аренды требуется **своя модель и свой датасет**, так как ценовые паттерны и диапазоны могут отличаться;
- интерфейс может показывать ML‑рекомендации для обоих типов аренды.

Целевое состояние:
- два набора CSV‑файлов:
  - `clean_train_short.csv` / `clean_test_short.csv`;
  - `clean_train_long.csv` / `clean_test_long.csv`;
- две модели в `mlrent/ml.py`:
  - `short_term_model`;
  - `long_term_model`;
- HTTP‑API:
  - либо единый endpoint `/predict` с полем `rental_term` (`"short_term" | "long_term"`),
  - либо два endpoint’а (`/predict/short`, `/predict/long`).

Интеграция с доменом:
- в `Listing` уже есть/будет поле `RentalTermType`;
- backend при запросе в ML‑сервис передаёт тип аренды;
- `MLPricingEngine` выбирает нужную модель/endpoint, но дальше поведение одинаково: возвращается рекомендованная цена.

---

### 4. Ограничения и допущения со стороны домена

Некоторые решения в доменной модели влияют на то, что именно мы включаем в ML:

- `MaxNights`:
  - может быть не задан (0 / `null` = «без лимита»);
  - на первом этапе не включаем в модель, чтобы не усложнять интерпретацию признаков.

- `Region` (регион как часть адреса):
  - в домене хранится `Region`, но в CSV его пока нет;
  - можно закодировать регион внутри ML‑сервиса через расширение признаков (например, объединять `city + region` в категорию), не меняя базовую схему CSV или добавив отдельное поле в будущих датасетах.

- `Rating` и отзывы:
  - полезны для оценки качества жильё, но напрямую в модель пока не входят;
  - их можно использовать позже для анализа ошибок (например, где модель систематически недооценивает топовые объекты).

Главный принцип: ML‑слой подстраивается под доменную модель, а не наоборот. Если появляется новый важный бизнес‑атрибут, он сначала появляется в `Listing`, а затем, при необходимости, добавляется в модель.

---

### 5. Роль ML в контексте pricing

Контекст `pricing` (`backend/internal/domain/pricing/pricing.go`) задаёт:
- `PriceBreakdown` — структуру, в которой backend хранит результат расчёта цены;
- `Calculator` — интерфейс, через который прикручиваются реализации (`memory`, ML);
- `PricingPort` и `HostListingPriceSuggestionHandler` — уровень `internal/app`, который отвечает за «подсказку цены» для хоста.

ML‑сервис:
- выступает в роли реализации `Calculator` через адаптер `MLPricingEngine`;
- принимает на вход признаки, согласованные с доменом (`Listing` + производные `minutes`, `way`, плюс `rental_term`);
- возвращает рекомендованную цену (`recommended_price`), которую backend мапит в `PriceBreakdown.Nightly`.

Важно:
- ML даёт **рекомендацию**, а не финальную истину;
- хост всегда может задать цену вручную;
- рекомендуется хранить текущую цену (`current_price`) в запросе, чтобы ML‑сервис и/или админка могли анализировать разницу.

---

### 6. Цели для развития ML‑части

Краткий список:

1. Жёстко зафиксировать маппинг CSV ↔ `Listing` в документации (`mlrent/readme.md`, `domain_model.md`), чтобы любой разработчик видел, какие поля откуда берутся.
2. Развести датасеты и модели для `short_term` и `long_term`, не смешивая разные рыночные сегменты.
3. Определить и стабилизировать HTTP‑контракт `/predict` (и, при необходимости, дополнительных endpoint’ов), в том числе:
   - обязательные поля;
   - формат ошибок;
   - поведение при недоступности модели.
4. Добавить простые метрики качества (MAE/MAPE по тестовым датасетам) и сделать их доступными:
   - либо через отдельный endpoint в ML‑сервисе;
   - либо через структурированное логирование, которое может использовать админка.
5. Поддерживать простоту кода: сохранять структуру `ml.py` и `main.py` максимально читаемой, чтобы другим участникам команды было просто адаптировать модели под новые данные.

