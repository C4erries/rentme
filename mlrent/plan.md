## План по реализации ML‑сервиса ценообразования

План опирается на очищенные датасеты (`clean_train.csv`, `clean_test.csv`) и доменную модель Rentme. Шаги намеренно укрупнённые.

---

### 1. Зафиксировать набор доменных полей для ценообразования

- Подтвердить список полей `Listing`, которые участвуют в ценообразовании и ML‑модели:
  - `Address.City`;
  - `Bedrooms` (из `rooms` в CSV);
  - `AreaSquareMeters` (из `total_area`);
  - планируемые: `Floor`, `FloorsTotal` (из `storey`, `storeys`);
  - планируемые: `RenovationScore`, `BuildingAgeYears`/`YearBuilt` (из `renovation`, `building_age_years`);
  - по необходимости — `GuestsLimit`, `MinNights`, `MaxNights`, `Rating` и др.
- Обновить `domain_model.md`, чтобы эти решения были зафиксированы на уровне документации.

### 2. Подготовить единый формат обучающего датасета

- Использовать согласованную схему CSV:
  - `id,city,price,minutes,way,rooms,total_area,storey,storeys,renovation,building_age_years`.
- Определить, как поле `price` переводится к ночной ставке:
  - в учебном варианте — делить на фиксированное количество ночей (например, 30);
  - в дальнейшем — генерировать данные сразу в формате «ночная цена» в минимальных денежных единицах (аналогично `NightlyRateCents`).
- В перспективе строить датасет из снапшотов `Listing` в БД (плюс синтетика), чтобы обучающие данные совпадали по структуре с продакшен‑данными.

### 3. Собрать и оформить базовую ML‑модель

- В `mlrent` реализовать простую модель регрессии (линейная модель/дерево), использующую поля:
  - `city`, `minutes`, `way`, `rooms`, `total_area`, `storey`, `storeys`, `renovation`, `building_age_years`;
  - категориальные фичи (`city`, `way`) закодировать one‑hot или аналогичным способом.
- Обучить модель на `clean_train.csv`, оценить качество на `clean_test.csv` и зафиксировать метрики.
- Сохранить модель и параметры предобработки признаков в артефакт (pickle/ONNX и т.п.) для использования в сервисе.

### 4. Обернуть модель в HTTP‑сервис

- Реализовать небольшой Python‑сервис (FastAPI/Flask) с эндпоинтом `POST /predict` по контракту из `mlrent/readme.md`.
- Добавить:
  - валидацию входных данных по схеме;
  - логирование запросов, предсказаний и ошибок (структурированные логи).

### 5. Интегрировать ML‑сервис в слой pricing

- В `backend/internal/infra` добавить адаптер `MLPricingEngine`, реализующий `pricing.Calculator`:
  - по `QuoteInput{ ListingID, Range, Guests }` считывать `Listing` из UoW;
  - формировать запрос к `POST /predict` в формате CSV‑схемы (включая `renovation`, `building_age_years`, если доступны);
  - преобразовывать ответ (`recommended_nightly_rate_cents`) в `PriceBreakdown`.
- Зарегистрировать `MLPricingEngine` как основную реализацию `pricing.Calculator`/`PricingPort` в `cmd/rentme/main.go`, оставив `memory.PricingEngine` как fallback для dev.

### 6. Включить в пользовательские сценарии и добавить наблюдаемость

- Убедиться, что `HostListingPriceSuggestionHandler` использует новый `PricingPort` и корректно отдаёт:
  - рекомендованную цену;
  - уровень «выше/ниже рынка»;
  - процент отклонения.
- Добавить структурированные логи (через `slog`/`obs.NewLogger`) вокруг вызовов ML‑сервиса:
  - входные фичи (без чувствительных данных);
  - предсказанная цена;
  - ошибки и таймауты.
- При необходимости — предусмотреть конфигурационный флаг, позволяющий отключать ML‑сервис и возвращаться к детерминированной модели ценообразования.

