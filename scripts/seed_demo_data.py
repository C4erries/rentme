import argparse
import json
import random
import string
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Tuple

try:
    from pymongo import MongoClient
except ImportError:  # pragma: no cover - optional dependency
    MongoClient = None


def _random_suffix(length: int = 6) -> str:
    return "".join(random.choices(string.ascii_lowercase + string.digits, k=length))


def generate_hosts() -> List[dict]:
    now = datetime.utcnow()
    return [
        {
            "_id": "host-agency-aurora",
            "email": "aurora@rentme.demo",
            "name": "Aurora Agency",
            "roles": ["host"],
            "created_at": now,
            "updated_at": now,
        },
        {
            "_id": "host-agency-len",
            "email": "leninvest@rentme.demo",
            "name": "LenInvest",
            "roles": ["host"],
            "created_at": now,
            "updated_at": now,
        },
        {
            "_id": "host-private-anna",
            "email": "anna@rentme.demo",
            "name": "Anna K.",
            "roles": ["host"],
            "created_at": now,
            "updated_at": now,
        },
        {
            "_id": "host-private-pavel",
            "email": "pavel@rentme.demo",
            "name": "Pavel D.",
            "roles": ["host"],
            "created_at": now,
            "updated_at": now,
        },
    ]


def _city_pool(term: str) -> Tuple[str, float]:
    if term == "short_term":
        cities = {
            "Moscow": 6800,
            "Saint Petersburg": 6200,
            "Sochi": 7400,
            "Kazan": 5400,
            "Kaliningrad": 5000,
        }
    else:
        cities = {
            "Moscow": 82000,
            "Saint Petersburg": 68000,
            "Yekaterinburg": 52000,
            "Kazan": 48000,
            "Sochi": 60000,
        }
    city = random.choice(list(cities.keys()))
    return city, cities[city]


def generate_listing(term: str, host_id: str, idx: int) -> dict:
    city, base_price = _city_pool(term)
    way = random.choice(["walk", "car", "walk"])
    rooms = random.choice([1, 2, 2, 3, 4])
    total_area = round(random.uniform(20, 120) + rooms * random.uniform(3, 10), 1)
    storeys = random.randint(5, 30)
    storey = random.randint(1, storeys)
    renovation = random.randint(3, 10)
    building_age = random.randint(1, 45)
    minutes = round(random.uniform(8, 35), 1)

    if term == "short_term":
        price = base_price + rooms * 850 + total_area * 85 + renovation * 120 - building_age * 35
        price += 500 if way == "walk" else 0
        price += random.uniform(-800, 900)
        price = max(1800, min(price, 20000))
        min_nights = 1
        max_nights = random.choice([7, 14, 21])
        price_unit = "night"
    else:
        price = base_price + rooms * 4200 + total_area * 230 + renovation * 180 - building_age * 60
        price += 1500 if way == "walk" else 0
        price += random.uniform(-9000, 12000)
        price = max(25000, min(price, 220000))
        min_nights = 14
        max_nights = random.choice([45, 90, 180])
        price_unit = "month"

    available_from = datetime.utcnow() + timedelta(days=random.randint(0, 30))
    listing_id = f"{term}-{idx}-{_random_suffix(4)}"

    return {
        "id": listing_id,
        "host": host_id,
        "title": f"{city} {term.replace('_', ' ')} stay #{idx}",
        "description": f"Autogenerated {term} listing in {city}.",
        "property_type": random.choice(["apartment", "loft", "cottage", "studio"]),
        "address": {
            "line1": f"{random.randint(1, 200)} Main street",
            "line2": "",
            "city": city,
            "region": city,
            "country": "RU",
            "lat": round(random.uniform(44.0, 60.0), 4),
            "lon": round(random.uniform(30.0, 85.0), 4),
        },
        "amenities": random.sample(
            ["wifi", "kitchen", "workspace", "parking", "sauna", "laundry", "balcony", "fireplace"],
            k=random.randint(3, 6),
        ),
        "guests_limit": max(2, rooms + 1),
        "min_nights": min_nights,
        "max_nights": max_nights,
        "house_rules": ["no parties", "no smoking"],
        "cancellation_policy_id": random.choice(["flexible", "standard", "strict"]),
        "tags": random.sample(["family", "city", "nature", "river", "view", "business"], k=2),
        "highlights": ["Generated demo listing"],
        "rate_rub": int(price),
        "price_unit": price_unit,
        "bedrooms": rooms,
        "bathrooms": random.choice([1, 1, 2]),
        "floor": storey,
        "floors_total": storeys,
        "renovation_score": renovation,
        "building_age_years": building_age,
        "area_sq_m": total_area,
        "thumbnail_url": "",
        "rating": round(random.uniform(4.2, 4.95), 2),
        "available_from": available_from.isoformat() + "Z",
        "rental_term": term,
        "state": "ACTIVE",
    }


def generate_payload(short_count: int, long_count: int):
    hosts = generate_hosts()
    short_listings = [
        generate_listing("short_term", random.choice(hosts)["_id"], idx + 1) for idx in range(short_count)
    ]
    long_listings = [
        generate_listing("long_term", random.choice(hosts)["_id"], idx + 1) for idx in range(long_count)
    ]
    return hosts, short_listings + long_listings


def upsert_documents(collection, docs: List[dict], key: str = "id"):
    if not docs:
        return
    operations = []
    for doc in docs:
        operations.append(
            {
                "filter": {key: doc.get(key)},
                "replacement": doc,
                "upsert": True,
            }
        )
    for op in operations:
        collection.replace_one(op["filter"], op["replacement"], upsert=op["upsert"])


def main():
    parser = argparse.ArgumentParser(description="Seed MongoDB with demo hosts and listings plus fixtures file.")
    parser.add_argument("--mongo-uri", default="mongodb://localhost:27017", help="Mongo connection string")
    parser.add_argument("--db", default="rentals", help="Database name")
    parser.add_argument("--listings-coll", default="listings", help="Listings collection")
    parser.add_argument("--users-coll", default="users", help="Users collection for hosts")
    parser.add_argument("--short-count", type=int, default=30, help="Number of short-term listings to generate")
    parser.add_argument("--long-count", type=int, default=30, help="Number of long-term listings to generate")
    parser.add_argument("--fixtures-path", default="backend/data/listings_seed.json", help="Where to write fixtures")
    parser.add_argument("--skip-mongo", action="store_true", help="Only write fixtures without touching Mongo")
    parser.add_argument("--seed", type=int, default=1234, help="Random seed for reproducibility")
    args = parser.parse_args()

    random.seed(args.seed)
    hosts, listings = generate_payload(args.short_count, args.long_count)

    fixtures_path = Path(args.fixtures_path)
    fixtures_path.parent.mkdir(parents=True, exist_ok=True)
    fixtures_path.write_text(json.dumps(listings, indent=2), encoding="utf-8")
    print(f"Fixtures written to {fixtures_path} ({len(listings)} listings)")

    if args.skip_mongo:
        return
    if MongoClient is None:
        print("pymongo is not installed; skipping Mongo seeding. Install with `pip install pymongo`.")
        return

    client = MongoClient(args.mongo_uri)
    db = client[args.db]
    listings_coll = db[args.listings_coll]
    users_coll = db[args.users_coll]

    upsert_documents(users_coll, hosts, key="_id")
    upsert_documents(listings_coll, listings, key="id")
    print(f"Upserted {len(hosts)} hosts and {len(listings)} listings into MongoDB at {args.mongo_uri}")


if __name__ == "__main__":
    main()
