## Общий план развития Rentme с ML‑ценообразованием

План укрупнённый, без лишней детализации, и опирается на текущую архитектуру: модульный монолит на Go (backend), SPA на React (frontend) и отдельный ML‑сервис в `mlrent/`.

---

### 1. Домен и данные

- Зафиксировать и довести до конца доменную модель для ценообразования:
  - в `Listing` (Go) добавить/подтвердить поля: `Floor`, `FloorsTotal`, `RenovationScore`, `BuildingAgeYears`/`YearBuilt`;
  - протянуть новые поля в DTO, HTTP‑хендлеры, in‑memory и Mongo‑репозитории, фикстуры (`backend/data/listings.json`).
- Синхронизировать домен с ML‑датасетом:
  - убедиться, что все признаки CSV (`minutes`, `way`, `rooms`, `total_area`, `storey`, `storeys`, `renovation`, `building_age_years`) либо хранятся в домене, либо однозначно из него выводятся;
  - описать в документации (README/domain_model) связь полей Listing ↔ ML‑фичей.

### 2. ML‑сервис и подготовка данных

- Довести учебный ML‑сервис в `mlrent` до «стабильного» состояния:
  - использовать текущую модель (PolynomialFeatures + StandardScaler + Lasso) и схему CSV;
  - оформить обучение (`train_from_csv`), предсказание (`predict`) и сбор фич (`build_feature_vector_from_dict`) как стабильный API внутри Python‑модуля.
- Описать формат обучающего датасета:
  - закрепить схему `clean_train.csv`/`clean_test.csv` и правила нормализации/масштабирования таргета;
  - спроектировать генерацию синтетических данных/фикстур на основе доменной модели Listing (для наполнения базы и обучения).
- Поднять и задокументировать HTTP‑сервис на FastAPI:
  - эндпоинты `/health` и `POST /predict` по схеме из `mlrent/readme.md`;
  - загрузка/обучение модели при старте сервера.

### 3. Интеграция ML‑сервиса в backend (pricing)

- Добавить инфраструктурный адаптер `MLPricingEngine`:
  - реализовать порт `pricing.Calculator` и `PricingPort`, вызывающий HTTP‑эндпоинт ML‑сервиса `/predict`;
  - по `QuoteInput{ ListingID, Range, Guests }` доставать Listing из UoW, собирать фичи (включая ремонт/возраст дома/этажность);
  - аккуратно обрабатывать ошибки и таймауты (фолбэк на простую детерминированную модель).
- В `cmd/rentme/main.go` зарегистрировать новый адаптер:
  - сделать выбор между `memory.PricingEngine` и `MLPricingEngine` конфигурируемым через переменные окружения (например, `PRICING_MODE=memory|ml`);
  - убедиться, что `HostListingPriceSuggestionHandler` прозрачно использует новый `PricingPort`.
- Добавить наблюдаемость:
  - структурированные логи вызовов ML‑сервиса (входные фичи, рекомендуемая цена, отклонение от текущей);
  - базовые метрики ошибок/таймаутов (через существующий obs‑слой).

### 4. Frontend и UX

- Обновить фронтенд для работы с новыми полями Listing:
  - добавить ввод/отображение этажности, ремонта, возраста дома при создании/редактировании объявления;
  - при необходимости обновить типы и DTO в `frontend/src/types`.
- Внедрить сценарий подсказки цены для хоста:
  - вызвать endpoint `/api/v1/host/listings/:id/price-suggestion` из UI страницы редактирования объявления;
  - отобразить рекомендованную цену, уровень «выше/ниже рынка» и процент отклонения;
  - дать возможность хосту применить рекомендованную цену одним кликом.

### 5. Сервисные задачи и качество

- Обновить документацию:
  - README по проекту, `mlrent/readme.md`, `domain_model.md` с учётом финальной схемы полей и интеграции;
  - краткое описание сценариев ценообразования и точек интеграции (backend ↔ ML‑сервис ↔ frontend).
- Минимально покрыть новые части тестами:
  - unit‑тесты на адаптер `MLPricingEngine` (мок HTTP‑сервиса);
  - smoke‑тест пути «хост запрашивает рекомендацию цены» (интеграционный или ручной сценарий).

---

### Первый шаг реализации (что делаем в ближайшие 2–3 промпта)

1. Привести ML‑сервис и планы к единому виду (уже частично сделано в `mlrent`).
2. Расширить доменную модель Listing новыми полями и протянуть их до HTTP‑слоя и фикстур.
3. Затем реализовать `MLPricingEngine` и конфигурируемое включение ML‑ценообразования в backend.

В следующих промптах будем по очереди: сначала дорабатывать домен и данные, затем интегрировать ML‑сервис в pricing, и после этого дорабатывать фронтенд‑UX.

