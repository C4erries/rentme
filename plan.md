## Общий план развития Rentme (до 10 задач)

План разбит на крупные логические блоки. Предполагается, что каждый блок можно реализовывать отдельной большой итерацией/промптом.

---

### Задача 1. Listing, ночи, адрес и UX мастера объявления

- Обновить доменную модель и валидацию `Listing`:
  - позволить `MaxNights` быть «безлимитным» (`0` или `null` = «неограниченно») без ошибки `ErrNightsRange`;
  - добавить/протащить во все DTO и HTTP‑обработчики поле `Region` и убрать зависимость пользовательского сценария от `Country`.
- Исправить публикацию объявления:
  - при переходе в `ListingActive` требовать валидный адрес (`City`, `Region`, `Line1`);
  - устранить ошибку `listings: address must be provided when activating`.
- Улучшить UX мастера объявления на frontend:
  - сделать шаги мастера (вкладки) кликабельными, а не только «назад/вперёд»;
  - добавить управляемый флаг «нет максимального количества ночей» (чекбокс поверх `MaxNights`);
  - заменить поле «страна» на «регион» во всех формах.
- Исправить баг `listing not selected` при запросе рекомендованной цены:
  - не вызывать запрос, пока нет `listingId`;
  - корректно инициировать запрос после создания объявления.
- На странице `host/listings` добавить кнопку «Вернуться на главную».

---

### Задача 2. ML‑модели для short_term / long_term и данные

- В домене:
  - зафиксировать поле `RentalTermType` (`short_term`/`long_term`) в `Listing` (и DTO);
  - убедиться, что это поле доступно в месте вызова `PricingPort`.
- В ML‑сервисе (`mlrent`):
  - разделить датасеты и модели для посуточной и долгосрочной аренды;
  - обновить `ml.py` и `main.py`, сохранив структуру файла, но добавив две модели (`short_term_model`, `long_term_model`);
  - реализовать разбиение данных для каждого типа аренды на train/test **≈90% / 10%**:
    - для долгосрочной аренды опираться на текущий CSV (существующий датасет);
    - для посуточной аренды сгенерировать новый CSV, по распределению параметров похожий на long‑term.
- В адаптере `MLPricingEngine`:
  - по `RentalTermType` выбирать, какую модель/endpoint использовать;
  - использовать ML‑подсказки и для short_term, и для long_term (каждый тип аренды — своя модель);
  - при недоступности ML корректно логировать и позволять переключить `PRICING_MODE` на `memory`.
- Генерация данных и заполнение базы:
  - подготовить утилиту, которая создаёт в Mongo:
    - не менее ~30 объявлений `short_term` и ~30 объявлений `long_term`;
    - несколько разных арендодателей (пара «агентств» и пара частных лиц);
  - сгенерированные объявления должны быть по параметрам (город, комнаты, площадь, этаж, ремонт, возраст дома, тип аренды) похожи на строки в CSV;
  - при необходимости утилита может одновременно обновлять/создавать CSV для посуточной выборки.

---

### Задача 3. Фото и S3‑хранилище (MinIO)

- Добавить в `docker-compose.yml` MinIO + web‑консоль как S3‑совместимое хранилище.
- На backend:
  - реализовать endpoint для загрузки фотографий объявления;
  - сохранять в `Listing` только URL/ключи файлов.
- На frontend:
  - обновить UI загрузки/просмотра фотографий в мастере объявления;
  - убедиться, что миниатюра (`ThumbnailURL`) и галерея работают с MinIO‑URL.

---

### Задача 4. Бронирование (Booking) и пользовательский поток

- Проверить/доработать контекст `booking`:
  - сущность `Booking` (диапазон дат, статус, итоговая цена, `GuestID`, `HostID`);
  - интеграцию с `availability` и `pricing`.
- На backend:
  - реализовать API создания/просмотра/отмены брони для гостя и хоста;
  - гарантировать, что бронь нельзя создать на занятые даты.
- На frontend:
  - починить кнопку «забронировать», чтобы она вела к созданию брони (а не абстрактному уведомлению);
  - вывести список броней в личных кабинетах.

---

### Задача 5. Маркетинговые страницы и система отзывов

- Сделать рабочими кнопки «Как это работает» и «Истории гостей»:
  - добавить соответствующие страницы;
  - наполнить их понятным описанием сервиса и примерами историй гостей.
- Реализовать систему отзывов:
  - доменные сущности `Review` и `Listing.Rating`;
  - API для добавления/получения отзывов;
  - UI‑формы для написания отзыва и отображение рейтинга на карточке объявления и в каталоге.

---

### Задача 6. Мессенджер (часть 1: сервис, ScyllaDB, backend API)

- Спроектировать отдельный сервис `messaging`:
  - gRPC‑API между основным backend и сервисом мессенджера;
  - хранение истории сообщений только в ScyllaDB;
  - основной backend работает только с Mongo и не пишет напрямую в Scylla.
- Модель данных:
  - `Conversation` (участники, `ListingID`/`BookingID`, `CreatedAt`);
  - `Message` (автор, текст, `SentAt`, статус прочтения).
- Реализовать backend‑слой (в монолите) поверх gRPC:
  - HTTP‑endpoint’ы для фронта: список диалогов, список сообщений, отправка сообщения;
  - привязка диалогов к объявлениям и броням (гость может написать конкретному хосту по конкретному объявлению).

---

### Задача 7. Мессенджер (часть 2: frontend и админка)

- На frontend:
  - реализовать UI чата (общий для гостей, хостов и админов);
  - интегрировать чат с карточкой объявления и экраном брони («написать хозяину»).
- В админке:
  - вывести список пользователей с фильтрацией/поиском;
  - при выборе пользователя открывать с ним диалог в том же интерфейсе мессенджера;
  - позволять админу писать пользователям так же, как пользователи пишут друг другу.
- Добавить базовый механизм уведомления о новых сообщениях (бейджи, обновление списка диалогов).

---

### Задача 8. Уведомления и пользовательские оповещения

- На backend:
  - добавить простой слой уведомлений без Kafka (прямые вызовы из use‑cases);
  - определить основные события: новая бронь, изменение статуса брони, новое сообщение, изменение статуса объявления.
- На frontend:
  - отрисовать уведомления в UI (иконки, счётчики непрочитанных, списки уведомлений).
- При необходимости предусмотреть простой механизм периодического опроса (polling) или WebSocket для обновления уведомлений и чатов.

---

### Задача 9. Админка и метрики ML‑моделей

- Реализовать административный раздел:
  - список пользователей (роль, email, дата создания);
  - переход в диалог с выбранным пользователем (см. Задачу 7);
  - компактный просмотр объявлений и броней.
- Интегрировать метрики ML‑моделей:
  - забрать MAE/MAPE и другие показатели из ML‑сервиса (endpoint или логирование);
  - отрисовать основные метрики и, по возможности, графики/таблицы.

---

### Задача 10. Инфраструктура и docker‑compose (без Kafka)

- Привести `docker-compose.yml` к целевому виду:
  - `rentme-backend`, `rentme-frontend`, `rentme-ml`, `mongo`, `minio`, `scylla`, (опционально) `messaging-service`;
  - корректные порты, сети и переменные окружения (`PRICING_MODE`, `ML_PRICING_URL`, креды к MinIO и т.п.).
- Полностью убрать Kafka из `docker-compose` и конфигурации backend (Kafka и событийная архитектура в проекте не используются).
- Проверить, что одна команда `docker-compose up` поднимает все нужные сервисы и позволяет пройти базовые сценарии:
  - каталог;
  - создание объявления;
  - ML‑подсказка цены;
  - бронирование;
  - чат;
  - работа админки.

